---
layout: post                          
title: TCP协议                            
subtitle:                             
date: 2019-08-15                      
author: luojiaqi                      
header-img: img/post-bg-re-vs-ng2.jpg 
catalog: true                         
tags:                                 
    计算机网络                             
---



# TCP包头格式

![img](https://static001.geekbang.org/resource/image/a7/bf/a795461effcce686a43f48e094c9adbf.jpg)

### 源端口号、目的端口号

和UDP一样，如果没有这两个端口号，数据就不知道要发给哪个应用。

### 序号

为了解决乱序问题，所以要给包编号，确认哪个应该先来，哪个应该后到。

### 确认序号

表示下一次应该收到的数据的序号。发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。

发出去的包要有确认，不然不知道对方有没有收到，如果没收到就应该重新发送，直到送达。

当且仅当ACK=1时确认序号才有效。

### 状态位

SYN是发起一个连接，ACK是回复，RST是重新连接，FIN是结束连接。

### 窗口大小

TCP要做流量控制，通信双方各声明一个窗口，标识自己当前能够处理的能力。

# TCP的三次握手

所有的问题，首先都要建立一个连接。

TCP的连接建立常称为三次握手。

> A：你好，我是A。
>
> B：你好A，我是B。
>
> A：你好B。

#### 为什么两次不行？

首先，不管两次三次，下面的过程是一样的：

A要发起一个连接，当发了第一个请求没有得到回复时，有很多种可能性，比如第一个请求包丢失了，或者没有丢，但是绕路了超时了，或者B不想建立连接，没有响应。

A没有收到回应，不能确认结果，于是重新发送。当有一个请求包到了B，这个时候A是不知道请求包已经到了B的，所以A还有可能再发。

而B收到了请求包，知道了A的存在，知道了A想和它建立连接。如果B不想建立连接，那么它不会响应，A会在重试一段时间后放弃，连接建立失败；如果B想建立连接，他会发送应答包给A。

而如果只有两次握手，那么这两种情况就会出问题：

+ 对B来说，这个应答包也是一样，不知道能不能到达A，这个时候B也不能认为连接已经建立好了，因为这个应答包可能丢失或者绕路，甚至A已经不在网络内，这都有可能。

+ 还有一种情况：A和B原先建立过连接，简单通信后结束了连接。A建立连接的时候重复发送了几次请求包，有的请求包绕了一大圈终于到达了B，这时B会认为这是一个新的连接请求，如果只有两次握手那么就会建立连接。而实际上这个连接是不应该存在的，只有B单相思而已。

B的应答包也可能发送多次，但只要有一次到达A，A就认为连接已经建立，因为对A来说，B能发送也能接收。第三次握手，A会给B发送一个应答之应答，B只有收到这个包之后才能确认连接的建立，因为只有等到这个消息后，对B来说，A能发送也能接收。

#### 为什么不用四次？

当然A发给B的应答之应答也可能丢失绕路，或者B不在网络内。似乎应该还要有个应答之应答之应答，这样下去就没完没了了。四次握手可以，四十次也可，但即使四百次也不能保证真真正正的可靠。所以只要双方消息都有去有回，就可以认为可以建立连接了。

大部分情况下，A和B建立连接后，A会马上发送数据，一旦A发送数据，很多问题都得到了解决。比如A发给B的应答丢失了，当A后续发送的数据到达B的时候，B可以认为这个连接已经建立；比如B不在网络内了，A发送的数据会报错，B不可达，这时A就知道连接已经断了。



总的来说：

如果只有两次握手，A可以确认B能够接收和发送，但B只能确认A可以发送，不确定A是否能接收，这种不确定性不能建立可靠连接。

如果有四次握手，A和B都可以确认对方能够发送和接收，但这其实只用三次握手就能实现，多一次握手并没有降低哪一方不可靠的不确定性，即没有增加可靠性，所以没有必要。

## TCP包的序号问题

三次握手过程中除了建立连接，双方主要是为了沟通TCP包的序号。

A要告诉B，我发的包是从哪个序号开始的，B一样要告诉A，B发的包是从哪个序号起始的。

序号不能都从1开始，为什么？因为这样往往会出现冲突。

例如，A连上B之后，发送了1，2，3共三个包，但发送3的时候，丢失了，或者绕路了，A就会重新发送，结果后来A掉线了，重新连上B之后，序号又从1开始，这时A只想发送1，2，没有发送3，但上次绕路的那个3又回来了到达了B，B会认为这就是下一个包，于是发生错误。

因此，每个连接都要有不同的序号。这个序号的起始序号是随着时间变化的，可以看成一个32位的计数器，每4微秒加一，如果到重复需要4个多小时，那个绕路的包早就没用了，因为IP包头里有个TTL，当TTL自减到0时这个包就会被丢弃。



双方建立了连接，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图：

![img](https://static001.geekbang.org/resource/image/66/a2/666d7d20aa907d8317af3770411f5aa2.jpg)

一开始，客户端和服务端都处于CLOSED状态。

先是服务端主动监听某个端口，处于LISTEN状态。

然后客户端主动发起连接SYN，之后处于SYN-SENT状态。

服务端收到发起的连接，返回SYN，并且ACK客户端的SYN，之后处于SYN-RCVD状态。

客户端收到服务端发送的SYN和ACK之后，发送ACK的ACK，处于ESTABLISHED状态，因为此时对客户端来说，服务端能够接收也能够发送。

服务端收到ACK的ACK之后，处于ESTABLISHED状态，因为此时对服务端来说，客户端能够发送也能够接收。

**注：**

第一次握手不能携带数据。因为会放大SYN FLOOD攻击，如果攻击者伪造很多握手报文并且携带很多数据，接受方会开辟大量缓存准备接收，内存容易耗尽，从而拒绝服务。

第三次握手可以携带数据。因为能够发出第三次握手报文的主机肯定能接收到第二次握手报文，所以能够发出第三次握手报文的应该是合法用户。尽管服务端的状态还没有established，但接收到第三次握手的瞬间状态就会变为established，携带的数据可以按正常流程走。

# TCP的四次挥手

> A：B，我不想玩了。
>
> B：哦，我知道了。

这个时候，只是A想断开连接，即A不再发送数据，但B能直接关闭吗？不能，因为有可能是A已经发完了最后数据然后告诉B准备断开了，但B的事情还没做完，还可以发送数据。这是称为半关闭状态。

这时A可以选择不再接收数据，也可以选择最后再接收一段数据，等待B也主动关闭。

> B：A啊，好吧，我也不玩了，拜拜。
>
> A：好的，拜拜。

这个时候整个连接就关闭了。

这中间可能出现的问题：

如果A说完“不玩了”之后，直接跑路，会有问题。因为B还没有发起结束，而如果A跑路，就算B发起结束，也得不到应答。

![img](https://static001.geekbang.org/resource/image/1f/11/1f6a5e17b34f00d28722428b7b8ccb11.jpg)

断开的时候，可以看到：当A说“不玩了”，就进入FIN-WAIT-1状态，B收到A的消息后，发送“知道了”，进入CLOSE-WAIT状态。

A收到B的“知道了”，就进入FIN-WAIT-2状态，如果这时候B直接跑路，则A将永远在这个状态。TCP协议里并没有对这个状态的处理，但是Linux有，可以调整tcp_fin_timeout这个参数，设置一个超时时间。

如果B没有跑路，会在将未完成的工作做完之后发送“我也不玩了”的请求，请求到达A时，A发送“直到B也不玩了”的ACK后，从FIN-WAIT-2状态结束。按理说这时A可以跑路了，但万一这最后一个ACK没送到B那呢？B会重新发送一个“我不玩了”，如果这时候A已经跑路，B就再也收不到ACK了，因此TCP协议要求A最后等待一段时间TIME-WAIT，这个时间要足够长，长到如果B没收到ACK的话，“B说不玩了”重发，A也会重发一个ACK并且足够时间到达B。

A直接跑路还有个问题，A的端口会空出来，但是B不知道，可能有些从B发向A的包还在路上，如果这时A的端口被一个新的应用占用了，那么这个新应用会收到上个连接种B发过来的包，虽然序列号是重新生成的，但要设置一个双保险防止混乱。所以也需要等待足够长时间，等到原来B发送的所有包都被丢弃了，再空出端口。

等待时间设为2MSL，MSL即Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。协议规定MSL为2分钟，实际应用种通常是30秒，1分钟和2分钟等。

还有一个异常情况：B在超过了2MSL后依然没有收到它发的FIN的ACK，按照TCP的原理，B还会重发FIN，这个时候A再收到这个包之后，认为已经等了足够长时间了，直接发送RST

# TCP状态机

![img](https://static001.geekbang.org/resource/image/da/ab/dab9f6ee2908b05ed6f15f3e21be88ab.jpg)

## 如何实现一个靠谱的协议

TCP为了保证顺序性，每个包都有一个ID，在建立连接时会商定起始ID是什么，然后按照ID一个个发送。为保证不丢包，对于发送的包都要应答，但不是一个一个应答，而是会应答某个之前的ID，表示这之前的都收到了，这种模式称为**累计确认**或**累计应答**。

为了记录所有发送的包和接收的包，TCP需要发送端和接收端分别都有缓存来保存这些记录。发送端的缓存里是按照包的ID一个个排列，根据处理的情况分为四个部分：

1.发送了且已经确认了的

2.发送了且尚未确认的

3.没有发送，但是已经等待发送的

4.没有发送，并且暂时不会发送的

这里为什么要区分第3和第4部分？没发送的，全发送了不就行了吗？



在TCP种，接收端会给发送端说明一个窗口的大小，叫Advertised window。这个窗口的大小应该等于第2部分加上第3部分，就是已经准备要发送但没法送的+已经发送了但还没确认的。超过了这个窗口大小的，接收端就忙不过来了，就不应该发送了。

所以，发送端需要保持下面这样的数据结构：

![img](https://static001.geekbang.org/resource/image/16/7b/16dcd6fb8105a1caa75887b5ffa0bd7b.jpg)

- LastByteAcked：第一部分和第二部分的分界线
- LastByteSent：第二部分和第三部分的分界线
- LastByteAcked + AdvertisedWindow：第三部分和第四部分的分界线

对于接收端，缓存的内容要简单些，分为三个部分：

1.接收且确认过的

2.还没接收，但是马上就可以接收的

3.还没接收，暂时也不能接收的

![img](https://static001.geekbang.org/resource/image/f7/a4/f7b1d3bc6b6d8e55f0951e82294c8ba4.jpg)

- MaxRcvBuffer：最大缓存的量；

- LastByteRead 之后是已经接收了，但是还没被应用层读取的；

- NextByteExpected 是第一部分和第二部分的分界线。

## 顺序问题与丢包问题

  接下来我们结合一个例子来看。

  还是刚才的图，在发送端来看，1、2、3 已经发送并确认；4、5、6、7、8、9 都是发送了还没确认；10、11、12 是还没发出的；13、14、15 是接收方没有空间，不准备发的。

  在接收端来看，1、2、3、4、5 是已经完成 ACK，但是没读取的；6、7 是等待接收的；8、9 是已经接收，但是没有 ACK 的。

  发送端和接收端当前的状态如下：

  - 1、2、3 没有问题，双方达成了一致。
  - 4、5 接收方说 ACK 了，但是发送方还没收到，有可能丢了，有可能在路上。
  - 6、7、8、9 肯定都发了，但是 8、9 已经到了，但是 6、7 没到，出现了乱序，缓存着但是没办法 ACK。

  根据这个例子，我们可以知道，顺序问题和丢包问题都有可能发生，所以我们先来看**确认与重发的机制**。

  假设 4 的确认到了，不幸的是，5 的 ACK 丢了，6、7 的数据包丢了，这该怎么办呢？

  一种方法就是**超时重试**，也即对每一个发送了，但是没有 ACK 的包，都有设一个定时器，超过了一定的时间，就重新尝试。但是这个超时的时间如何评估呢？这个时间不宜过短，时间必须大于往返时间 RTT，否则会引起不必要的重传。也不宜过长，这样超时时间变长，访问就变慢了。

  估计往返时间，需要 TCP 通过采样 RTT 的时间，然后进行加权平均，算出一个值，而且这个值还是要不断变化的，因为网络状况不断的变化。除了采样 RTT，还要采样 RTT 的波动范围，计算出一个估计的超时时间。由于重传时间是不断变化的，我们称为**自适应重传算法**（**Adaptive Retransmission Algorithm**）。

  如果过一段时间，5、6、7 都超时了，就会重新发送。接收方发现 5 原来接收过，于是丢弃 5；6 收到了，发送 ACK，要求下一个是 7，7 不幸又丢了。当 7 再次超时的时候，有需要重传的时候，TCP 的策略是**超时间隔加倍**。**每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍**。**两次超时，就说明网络环境差，不宜频繁反复发送。**

  超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？

  有一个可以快速重传的机制，当接收方收到一个序号大于下一个所期望的报文段时，就检测到了数据流中的一个间格，于是发送三个冗余的 ACK，客户端收到后，就在定时器过期之前，重传丢失的报文段。

  例如，接收方发现 6、8、9 都已经接收了，就是 7 没来，那肯定是丢了，于是发送三个 6 的 ACK，要求下一个是 7。客户端收到 3 个，就会发现 7 的确又丢了，不等超时，马上重发。

  还有一种方式称为**Selective Acknowledgment** （**SACK**）。这种方式需要在 TCP 头里加一个 SACK 的东西，可以将缓存的地图发送给发送方。例如可以发送 ACK6、SACK8、SACK9，有了地图，发送方一下子就能看出来是 7 丢了。

## 流量控制问题

在对于包的确认中，会携带一个窗口的大小。

假设窗口不变的情况，始终为9，当第4个包的确认来的时候，会右移一格，这时第13个包也可以发送了。

![img](https://static001.geekbang.org/resource/image/73/33/7339fd8973865164d25227cac206ca33.jpg)

这时假设发送端发的太快，会将10、11、12、12全部发送完毕，之后就停止发送，这时未发送可发送部分为0

![img](https://static001.geekbang.org/resource/image/06/d2/06cc25118730fbf611eb315705420ed2.jpg)

当对于包5的确认到达时，又右移一格

![img](https://static001.geekbang.org/resource/image/bd/c3/bddb59ebbf7eecc4853cafce0bb1dcc3.jpg)

如果接受方处理得比较慢，导致缓存中没有空间了，可以通过确认信息修改窗口得大小，甚至可以设为0，则发送方将暂时停止发送。

假设一个极端情况，接收端的应用一直不读取缓存中的数据，当数据包6确认后，窗口大小不能再是9，要缩小变为8。

![img](https://static001.geekbang.org/resource/image/92/31/92f66b1556b76c46c669aba232d35a31.jpg)

这个新窗口没有平行右移一格，而是左侧的边界右移一个，窗口大小从9变成8。

![img](https://static001.geekbang.org/resource/image/a7/ba/a78f5195ebf9b4f9dc4ea5a9b91e94ba.jpg)

如果接收端还是一直不处理数据，随着确认的包越来越多，窗口越来越小，直到为0。

![img](https://static001.geekbang.org/resource/image/15/d2/150f28d9e745952f5968eff05e3f0ad2.jpg)

当这个窗口通过包 14 的确认到达发送端的时候，发送端的窗口也调整为 0，停止发送。

![img](https://static001.geekbang.org/resource/image/30/30/3014a6a259f74b0c950bf3067581ac30.jpg)

发送方会定时发送窗口探测数据报，看是否有机会调整窗口的大小。当接受方比较慢的时候，要防止这种情况：空出来一个字节就赶快告诉发送方，然后马上又填满了。当窗口太小时，可以不更新窗口直到达到一定大小，或者缓冲区一半为空，才更新窗口。

## 拥塞控制问题

拥塞控制也是通过窗口的大小来控制，前面的滑动窗口rwnd是怕发送方把接收方的缓存塞满，而拥塞窗口cwnd是怕把网络塞满。

LastByteSent - LastByteAcked <= min {cwnd, rwnd} ，是拥塞窗口和滑动窗口共同控制发送的速度。

发送方怎么判断网络是不是满了呢？对于TCP协议来说，它根本不知道整个网络路径会经历什么，所以这个比较难。

对于到网络上，通道的容量 = 带宽 × 往返延迟。

如果我们设置发送窗口，使得发送但未确认的包为为通道的容量，就能够撑满整个管道。

![img](https://static001.geekbang.org/resource/image/db/e6/db8510541662281175803c7f9d1fcae6.jpg)

如图，假设往返时间为8s，去4s回4s，每秒发送一个包，每个包1024byte。已经过去了8s，则8个包都发出去了，其中前4个包已经到达接收端，但ACK还没有返回，不能算发送成功，后4个包还在路上，还没被接收。这个时候，整个管道正好塞满，在发送端，已发送未确认的为8个包，正好等于带宽，也即每秒发送一个包，乘以来回时间8s。

如果在这个基础上扩大窗口，使得单位时间内可以发送更多的包，会出现什么现象?

原来发送一个包，从一段到达另一端，假设一共经过4个设备，每个设备处理一个包耗时1s，所以到达另一端需要耗费4s，如果发送得更快，则单位时间内会有更多得包到达这些中间设备，如果这些设备还是只能每秒处理一个包得话，多出来得包就会被丢弃，这是我们希望避免的。

可以想想其他办法，例如在这些设备上加缓存，处理不过来的在队列里排着，这样包就不会丢失，但是会增加时延，缓存中的包4s肯定到不了接收端，如果时延到达一定程度就会超时重传，这也是我们不想看到的。

TCP的拥塞控制主要来避免两种现象：**包丢失**和**超时重传**。一旦出现这些现象，说明发送速度太快了。

一条TCP连接开始，cwnd设置为一个报文段，一次只能发一个；当收到这一个确认时，cwnd加1，于是能够一次发两个；当这两个确认到来的时候，每个确认cwnd加1，两个确认cwnd加2，于是能够一次发四个；当这四个的确认到来时，每个确认加1，四个确认加4，于是一次能够发八个。可以看出是指数增长。

增长到什么时候减缓速度呢？有一个值ssthresh为65535个字节，当超过这个值，意味着可能快满了，要慢一点。

每收到一个确认后，cwnd加1/cwnd。接着上面的过程，一次发送八个，当八个的确认到来时，每个确认增加1/8，八个确认一共增加1，于是一次能够发送九个，变为线性增长。

线性增长还是增长，带宽总会满的。

拥塞的一种表现形式是丢包，需要超时重传，这个时候，将 sshresh 设为 cwnd/2，将 cwnd 设为 1，重新开始慢启动。这真是一旦超时重传，马上回到解放前。但是这种方式太激进了，将一个高速的传输速度一下子停了下来，会造成网络卡顿。

前面我们讲过**快速重传算法**。当接收端发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速的重传，不必等待超时再重传。TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，cwnd 减半为 cwnd/2，然后 sshthresh = cwnd，当三个包返回的时候，cwnd = sshthresh + 3，也就是没有一夜回到解放前，而是还在比较高的值，呈线性增长。





TCP 的拥塞控制主要来避免的两个现象都是有问题的。

**第一个问题**是丢包并不代表着通道满了，也可能是管子本来就漏水。例如公网上带宽不满也会丢包，这个时候就认为拥塞了，退缩了，其实是不对的。

**第二个问题**是 TCP 的拥塞控制要等到将中间设备都填充满了，才发生丢包，从而降低速度，这时候已经晚了。其实 TCP 只要填满管道就可以了，不应该接着填，直到连缓存也填满。

为了优化这两个问题，后来有了**TCP BBR 拥塞算法**。它企图找到一个平衡点，就是通过不断的加快发送速度，将管道填满，但是不要填满中间设备的缓存，因为这样时延会增加，在这个平衡点可以很好的达到高带宽和低时延的平衡。

![img](https://static001.geekbang.org/resource/image/a2/4c/a2b3a5df5eca52e302b75824e4bbbd4c.jpg)